COFFEE SHOP QUEUE SYSTEM - FLOW DIAGRAM
==========================================

1. ORDER CREATION
=================
Customer places order → Order object created → Added to priority queue

[Customer] → [Order Object] → [Priority Queue]
    ↓              ↓              ↓
  Name         UUID ID        VIP/Mobile/Regular
  Items        Timestamp      Status: QUEUED
  Priority     Wait Time      Position: ?

2. QUEUE STRUCTURE
==================
Three Priority Queues + Main Queue

Priority Queues:          Main Queue (Rebuilt):
┌─────────────┐          ┌─────────────────────┐
│ VIP Queue   │          │ VIP1 → VIP2 → VIP3  │
│ [Order1]    │          │ Mobile1 → Mobile2   │
│ [Order2]    │          │ Regular1 → Regular2 │
└─────────────┘          └─────────────────────┘
┌─────────────┐
│ Mobile Queue│
│ [Order3]    │
│ [Order4]    │
└─────────────┘
┌─────────────┐
│ Regular Queue│
│ [Order5]    │
│ [Order6]    │
└─────────────┘

3. ORDER PROCESSING FLOW
========================

QUEUED → PREPARING → COMPLETED
  ↓         ↓
CANCELLED  CANCELLED

Step 1: Get Next Order
- Take first order from main queue (highest priority)
- Remove from priority queue
- Change status to PREPARING
- Move to preparing_orders dict

Step 2: Complete Order
- Remove from preparing_orders
- Change status to COMPLETED
- Add to completed_orders list
- Update statistics

4. REAL-TIME UPDATES
====================
SocketIO Events:

Order Created:
[API] → [QueueManager] → [SocketIO] → [All Clients]
  ↓           ↓              ↓
Create    Add to Queue    Broadcast
Order     Update Stats    queue_updated

Order Started:
[Staff] → [API] → [QueueManager] → [SocketIO] → [Staff Dashboard]
  ↓         ↓           ↓              ↓
Click     Get Next    Move to       Broadcast
"Next"    Order       Preparing     order_started

Order Completed:
[Staff] → [API] → [QueueManager] → [SocketIO] → [All Clients]
  ↓         ↓           ↓              ↓
Click     Complete    Move to       Broadcast
"Done"    Order       Completed     order_completed

5. DATA FLOW EXAMPLE
====================

Initial State:
VIP Queue: [Order1, Order2]
Mobile Queue: [Order3]
Regular Queue: [Order4, Order5]
Main Queue: [Order1, Order2, Order3, Order4, Order5]

After get_next_order():
VIP Queue: [Order2]
Mobile Queue: [Order3]
Regular Queue: [Order4, Order5]
Main Queue: [Order2, Order3, Order4, Order5]
Preparing: {Order1}

After complete_order(Order1):
VIP Queue: [Order2]
Mobile Queue: [Order3]
Regular Queue: [Order4, Order5]
Main Queue: [Order2, Order3, Order4, Order5]
Preparing: {}
Completed: [Order1]

6. PERFORMANCE CHARACTERISTICS
==============================

Time Complexities:
- Add Order: O(n) - due to queue rebuild
- Get Next: O(n) - due to remove + rebuild
- Complete: O(1) - hash table lookup
- Cancel: O(n) - linear search + rebuild

Space Complexity: O(n) where n = number of orders

7. KEY DESIGN DECISIONS
========================

Why deque()?
- O(1) add/remove from both ends
- Efficient for FIFO operations
- Memory efficient

Why dual queues?
- Easy priority management
- Clear separation of concerns
- Flexible for adding priorities

Why rebuild main queue?
- Ensures correct ordering
- Maintains consistency
- Simple to understand

Trade-offs:
+ Simple and clear
+ Easy to debug
+ Flexible priority system
- O(n) operations
- Memory overhead
- Not optimized for scale
